volatile:Java虚拟机提供轻量级的同步机制
1.保证可见性
2.不保证原子性
3.禁止指令重排

JMM约定:
1.线程解锁前,必须把共享变量立刻刷回主内存
2.线程加锁前,必须读取主内存中的最新值到工作内存中
3.加锁和解锁是同一把锁

8中操作：
read(读取):作用于主内存变量,它把一个变量的值从主内存传输到线程的工作内存中,以便随后的load动作使用.
load(载入):作用于工作内存的变量,它把read操作从主内存中变量放入工作内存中.
use(使用):作用于工作内存中的变量,它把工作内存的变量传输给执行引擎,
            每当虚拟机遇到一个需要使用到变量的值,就会使用到这个指令.
assign(赋值):作用于工作内存中的变量,它把一个从执行引擎中接受到的值放入工作内存的变量副本中.
store(存储):作用于主内存中的变量,它把一个从工作内存中一个变量的值传递到主内存中,以便后续的write使用.
write(写入):作用于主内存中的变量,它把store操作从工作内存中得到的变量的值放入主内存的变量中.
lock(锁定):作用于主内存的变量,把一个变量标识为线程独占状态.
unlock(解锁):作用于主内存的变量,它把一个处于锁定状态的变量释放出来,释放后的变量才可以被其他线程锁定.

规定:
1.不允许read和load、store和write操作之一单独出现.即使用了read必须load,使用了store必须write
2.不允许线程丢弃他最近的assign操作,即工作变量的数据改变了之后,必须告知主内存
3.不允许一个线程将没有assign的数据从工作内存同步回主内存
4.一个新的变量必须在主内存中诞生,不允许工作内存直接使用一个未被初始化的变量.就是对变量实施use、store之前,
    必须经过assign和load操作
5.一个变量同一时间只有一个线程能对其进行lock.多次load后,必须执行相同次数的unlock才能解锁.
6.如果对一个变量进行lock操作,会清空所有工作内存中此变量的值,在执行引擎使用这个变量前,
    必须重新load或assign操作初始化变量的值.
7.如果一个变量没有被lock,就不能对其进行unlock操作.也不能unlock一个被其他线程锁住的变量
8.对一个变量进行unlock操作之前,必须把此变量同步回主内存

CAS:比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么执行操作！如果不是就一直循环，使用的是自旋锁。
缺点:
1.循环会耗时
2.一次性只能保证一个共享变量的原子性
3.会存在ABA问题

定位死锁,解决问题:
1、使用jps定位进程号，jdk的bin目录下:有一个jps(jps -l)
2、使用jstack 进程进程号 找到死锁信息(jstack是jvm中自带的堆栈跟踪工具)(jstack 进程号)

对原生锁的优化:
1.自旋锁(默认次数:10)
2.自适应自旋锁,次数由前一次自旋锁次数和锁拥有者的状态决定
3.锁消除,在动态编译同步代码块的时候，JIT编译器借助逃逸分析技术来判断锁对象是否只被一个线程访问，而没有其他线程，这时就可以取消锁了。
4.锁粗化,当JIT编译器发现一系列的操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环中，此时会将加锁同步的范围粗化到整个操作系列的外部。

如何实现多线程之间的通讯?:
可以通过中断 和 共享变量的方式实现线程间的通讯和协作
1.synchronized加锁线程的Object类的wait()/notify()/notifyAll()
2.ReentrantLock类加锁线程的Condition类的await()/signal()/signalAll()

悲观锁对任何数据的操作都是加锁的.
乐观锁的核心是CAS,CAS包括内存值,预期值,新值,自旋锁