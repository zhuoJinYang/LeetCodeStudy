系统从磁盘读取数据到内存时是以磁盘块(block)为基本单位的,位于同一个磁盘块中的数据会被一次性读取出来
InnoDB存储引擎中有页(page)的概念,页是其磁盘管理的最小单位.
InnoDB存储引擎中默认每页的大小为16KB,可通过参数innodb_page_size将页的大小设置为4K、8K、16K、32K、64K
```mysql
show variables like 'innodb_page_size'
```
系统一个磁盘块的存储空间没有这么大,因此InnoDB每次申请磁盘空间时会以若干地址连续磁盘块来达到页的大小,
InnoDB在查询时如果页中每条数据都有助于定位数据记录的位置,会减少磁盘的I/O次数,提高查询效率
B-Tree定义一条记录为一个二元组[key,data],key为记录的键值(表中主键值),data为记录的数据(除主键)

B+Tree是B-Tree基础上的一种优化:
非叶子节点只存储键值信息
所有叶子节点之间都有一个链指针
数据记录都存放在叶子节点中

B+Tree上有两个头指针,一个指向根节点,另一个指向关键字最小的叶子节点,所有叶子节点之间是一种链式环结构.
因此B+Tree可进行两种查找运算:1、对于主键的范围查找和分页查找。2、从根节点开始,进行随机查找

B+Tree索引可以分为聚集索引(clustered index)和辅助索引(secondary index)
聚集索引的叶子节点存放的是整张表的行记录数据。
辅助索引的叶子节点不包含记录的全部数据,而是存储相应行数据的聚集索引键(主键和索引列信息),再通过聚集索引找到完整数据

每个索引对应一棵树

索引失效:
1.查询条件包含or,可能导致失效
2.字段类型是字符串,where用引号括起来,否则索引失效
3.like可能导致失效(%a)
4.联合索引不按照最左前缀原则
5.索引列使用mysql内置函数,运算(+,-,*,/),比较(!=,<,>,not in,is null,is not null)
6.左连接查询或右连接查询关联字段编码格式不一致
7.使用全表扫描比索引快

页格式：
名称                       空间                  含义和作用
File Header             38字节                文件头
Page Header             56字节                页头
Infimum & supremum      26字节                边界
User Records            不固定                用户记录
Free Space              不固定                空闲空间
Page Directory          不固定                页目录
File Trailer            8字节                 文件结尾信息

每页剩余空间还剩下(给用户):
16 * 15/16(InnoDB 留出 1/16 的页面空闲以供将来插入和更新索引记录) * 1024 - 128(38+56+26+8) = 15232

行格式：
名称                  空间              含义和作用
行记录头信息            5字节       包含一些标志位、数据类型等信息
可变长度字段列表        不固定       保存可变长度的字段占用的字节数
null值列表             不固定       存储可以为null的字段是否为null
事务ID和指针字段        6+7字节      数据行包含一个6字节的事务ID和7字节的回滚指针
实际数据                不固定       真实数据

索引记录包含当前索引的值、6字节的指针信息、5字节的行标头(用来指向下一层数据页的指针)
主键id(bigint[8]) 15232 / 19 (8+6+5) = 801 --(页目录[6条数据] 801 / 6 = 134 (268字节))--> 787 --> 619369 叶子节点
主键id(int[4]) 15232 / 15(4+6+5) = 1015 --(页目录[6条数据] 1015 / 6 = 170 (340字节))--> 993 --> 986049 叶子节点

慢查询：
超过long_query_time参数设定的时间阈值的执行时间的sql语句
解读：
一、记录时间
二、用户名,用户IP信息,线程ID号
三、执行花费的时间(ms),执行获得锁的时间,获得的结果行数,扫描的数据行数
四、这SQL执行的时间戳
五、具体的SQL语句

MVCC(多版本并发控制)
脏读：一个事务对一条记录做修改,事务提交前,另一个事务也读取同一条记录,读取到了未提交的脏数据
不可重复读：一个事务在读取某些数据已经发生了改变、或已被删除
幻读：一个事务相同的查询读取以前检索过的数据,发生其他事务插入了满足查询条件的新数据

事务特性：
原子性、隔离性、一致性、持久性

隔离级别：
1.读取未提交 - READ UNCOMMITTED(脏读、不可重复读、幻读) -> 每次读取版本链的最新数据即可
2.读取已提交 - READ COMMITTED(不可重复读、幻读) -> 读取已经提交了的事务(每次读取数据前都生成一个ReadView)
3.可重复读 - REPEATABLE READ(幻读) -> 读取已经提交了的事务(在第一次读取数据时生成一个ReadView)
4.可串行化 - SERIALIZABLE -> 通过加锁控制

ReadView：
m_ids：生成read view时,活跃的事务id集合
min_trx_id：m_ids的最小值
max_trx_id：生成read view时,系统应该分配下一个事务id值
creator_trx_id：创建read view的事务id

被访问行事务ID：
大于等于max_trx_id,当前数据行不可见
小于min_trx_id,可以直接获取数据
等于creator_trx_id,说明是当前事务修改的记录,可直接访问
大于min_trx_id,小于max_trx_id,若在m_ids中,当前记录行不能访问,负责可以访问数据行

